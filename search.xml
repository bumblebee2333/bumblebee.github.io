<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[view篇1--------初识view]]></title>
    <url>%2F2019%2F04%2F12%2Fview%E7%AF%871-%E5%88%9D%E8%AF%86view%2F</url>
    <content type="text"><![CDATA[Android View篇—–初识viewview简介在Android操作系统中，几乎所有的UI元素都是基于View和ViewGroup创建出来的。View就是一块可以用来进行绘画，可以处理输入事件进行交互的矩形区域，而ViewGroup就是一种可以容纳View的矩形容器。 下图就是ViewGroup和View组成的UI布局结构。View和ViewGroup通过这种树形结构组合在一起，构成了我们在手机屏幕上看到的一个个的复杂的界面。 view ViewGroup和View是组合模式的典型应用。View是基本的控件元素，ViewManager接口定义了添加、删除View的接口addView、removeView，ViewGroup实现了ViewParent的接口，因此可以作为容器管理View，同时ViewGroup又继承自View，可以被其他的ViewGroup管理。这样ViewGroup和View就可以组成上面的树状结构了。 ViewManager结构图 实际的代码实现过程中很少会直接使用ViewGroup和View，而是使用继承自它们的之类，如FrameLayout、LinearLayout、ListView等是ViewGroup的子类，TextView、ImageView、SurfaceView等是View的子类。 View的位置参数想要学好view，写出自己的view就必须搞清楚view的位置参数。 view的位置主要是由它的四个顶点决定的，分别对应View的四个属性：top、left、right、bottom。 view的位置参数 view位置参数具体总结 MotionEvent在手指接触屏幕后所产生的一系列事件中，典型的事件类型有如下几种： ACTION_DOWN: 手指刚接触屏幕； ACTION_MOVE: 手指在屏幕上移动 ACTION_UP: 手指在屏幕上松开的一瞬间 上述是三种典型的点击事件，还有ACTION_POINTER_DOWN等。通过点击事件我们可以获得点击事件发生的x和y坐标。 系统提供了两种方法： event.getX() / event.getY() 返回的是相对于当前view左上角的坐标x和y event.getRawX() / event.getRawY() 返回的是相对于手机屏幕左上角的坐标x和y TouchSlopTouchSlop是系统所能识别出的被认为是滑动的最小距离。也就是，当手指在屏幕上滑动时，如果两次滑动的这个距离小于这个常量，系统就不认为你是在进行滑动操作。这个常量和设备有关，通常用如下方式获得这个常量：1ViewConfiguration.get(getContext()).getScaledTouchSlop() VelocityTracker速度追踪，用于追踪手指在滑动的过程中的速度，包括水平和竖直方向的速度。首先，在view的onTouchEvent方法中追踪当前单击事件的速度，123VelocityTracker velocityTracker = VelocityTracker.obtain();velocityTracker.addMovement(event); 接着，当我们想知道当前的滑动速度时，这个时候可以采用如下方式来获得当前的速度：123velocityTracker.computeCurrentVelocity(1000);int xVelocity = (int) velocityTracker.getXVelocity();int yVelocity = (int) velocityTracker.getYVelocity(); 有两点需要注意： 获取速度之前必须要先计算速度，即getXVelocity和getYVelocity这两个方法前必须要调用computeCurrentVelocity方法。 这里的速度是指一段时间内手指所滑过的像素数，比如将时间设为1000ms,在1s内，手指在水平方向从左向右滑过100像素，那么水平速度就是100。注意速度可以为负值，即当手指从右向左滑动的时候。另外，computeCurrentVelocity这个方法的参数表示的是一个时间单元或者说是时间间隔，单位是毫秒(ms)。 最后，当不需要使用它的时候，需要调用clear方法来重置并回收内存：12velocityTracker.clear();velocityTracker.recycle(); GestureDetector 在写项目的时候，想要实现图片双指缩放的功能，在网上看见了有用GestureDetector来实现的方法，但是一般在onTouchEvent中实现就可以，主要还是看个人习惯，像双击的话就用GestureDetector中的方法比较方便。 GestureDetector用于手势检测，用于辅助检测用户的单击、滑动、长按、双击等行为。 GestureDetector这个类对外部提供了两个接口和一个外部类，其中包括： 接口：OnGestureListener OnDoubleTapListener 内部类：SimpleOnGestureListener OnGestureListener基本使用首先在MainActivity中定义我们的手势监听器，并让的当前的Acticity来实现监听接口：1234567891011//定义手势监听器GestureDetector mGestureDetector;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mGestureDetector = new GestureDetector(this,this); //解决长按屏幕后无法拖动的现象 mGestureDetector.setIsLongpressEnabled(false);&#125; 实现接口中的回调方法：12345678910111213141516171819202122232425262728293031323334353637383940//手指轻轻触摸屏幕的一瞬间，由一个ACTION_DOWN触发@Overridepublic boolean onDown(MotionEvent e) &#123; System.out.println(&quot;onDown&quot;); return false;&#125;//手指轻轻触摸屏幕,尚未松开或拖动，由一个ACTION_DOWN触发//注意和onDown()的区别，他强调的是没有松开或者拖动的状态@Overridepublic void onShowPress(MotionEvent e) &#123; System.out.println(&quot;onShowPress&quot;);&#125;//手指(轻轻触摸屏幕后)松开，伴随着一个ACTION_UP而触发，这是单机行为@Overridepublic boolean onSingleTapUp(MotionEvent e) &#123; System.out.println(&quot;onSingleTapUp&quot;); return false;&#125;//手指按下屏幕并拖动，由一个ACTION_DOWN,多个ACTION_MOVE触发，这是拖动行为@Overridepublic boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123; System.out.println(&quot;onScroll&quot;); return false;&#125;//用户长久的按着屏幕不放，即长按@Overridepublic void onLongPress(MotionEvent e) &#123; System.out.println(&quot;onLongPress&quot;);&#125;//用户按下触摸屏，快速滑动后松开，由一个ACTION_DOWN,多个ACTION_MOVE和一个ACTION_UP触发，这是快速滑动行为@Overridepublic boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#123; System.out.println(&quot;onFling&quot;); return false;&#125; 最后将Activity中的OnTouchEvent事件交给手势监听器处理：1234@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; return gestureDetector.onTouchEvent(event);&#125; OnDoubleTapListener基本使用:同样的让MainActivity也实现OnDoubleTapListener接口。1public class MainActivity extends Activity implements OnGestureListener,OnDoubleTapListener 实现对应的抽象方法：123456789101112131415161718192021//双击，由两次连续的单击组成，它不可能和onSingleTapConfirmed共存(当系统接受到双击事件的时候会在两次点击之间触发一次下面的方法)@Overridepublic boolean onDoubleTap(MotionEvent e) &#123; System.out.println(&quot;onDoubleTap&quot;); return false;&#125;//严格的单击行为//和onSingleTapUp的区别：如果触发了onSingleTapConfirmed，那么后面不可能在紧跟着另一个单击行为，即这只可能是单击，而不可能是双击中的一次单击@Overridepublic boolean onSingleTapConfirmed(MotionEvent e) &#123; System.out.println(&quot;onSingleTapConfirmed&quot;); return false;&#125;//表示发生了双击行为，在双击的期间，ACTION_DOWN ACTION_MOVE ACTION_UP都会触发此回调(当系统接收到双击事件的时候,在每一次的结束触发下面的方法一次) @Overridepublic boolean onDoubleTapEvent(MotionEvent e) &#123; System.out.println(&quot;onDoubleTapEvent&quot;); return false;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[]]></title>
    <url>%2F2019%2F04%2F08%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[onDraw()方法中的Canvas的大小是多少 控件的大小是wrap_content时 getMeasuredWidth()是如何测量的 IPC过程]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
