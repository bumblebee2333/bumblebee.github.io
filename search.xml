<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[简单总结FileProvider]]></title>
    <url>%2F2019%2F05%2F19%2F%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93FileProvider%2F</url>
    <content type="text"><![CDATA[概述FileProvider继承自ContentProvider 从英语翻译过来就是文件提供 也就是文件共享 当我们需要使用本地的文件时(这样说好像不太对) 例如调用相机拍照 需要将照片显示在屏幕上 照片是需要缓存在sdcard的缓存文件目录中的 这时就会用到FileProvider。 还有一个用处就是在自动安装apk上 我们经常会遇到app更新 此时系统会自动弹出一个框让我们更新并安装。 FileProvider使用时需要注意的一个地方就是Android7.0版本以后和Android4.4之前 对uri(通用资源标识符 Android上可用的每种资源-图像、视频片段都可以用uri来表示)的操作是不一样的。 相机获取本地图片最近写了一个demo 主要是想实现从相册 本地获取的照片通过画布展现在屏幕上 并实现图片的保存。 下面就贴下我写的开启照相机拍照的代码：1234567891011121314151617181920public void takePhoto()&#123; //判断设备中是否存在sdcard String SDState = Environment.getExternalStorageState(); Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); if(SDState.equals(Environment.MEDIA_MOUNTED))&#123; File outputImage = new File(getExternalCacheDir(),"output_image.jpg"); if(!outputImage.exists())&#123; outputImage.mkdir(); &#125; if(Build.VERSION.SDK_INT&gt;=24)&#123; imageUri = FileProvider.getUriForFile(this, this.getPackageName()+".android7.fileprovider",outputImage); Log.e("tag",imageUri.toString()); &#125;else &#123; imageUri = Uri.fromFile(outputImage); &#125; &#125; intent.putExtra(MediaStore.EXTRA_OUTPUT,imageUri); startActivityForResult(intent,SELECT_PIC_BY_TAKE_PHOTO);&#125; 解决FileUriExposedException在没有用FileProvider 只用Uri.fromFile()是对file://的访问 对于Android7.0来说是禁止的 要在应用间共享文件 应发送一项content://URL 并授予URL临时访问权限 这时就需要用到FileProvider。 使用FileProvider兼容拍照需要以下几个步骤： 声明provider123456789&lt;provider android:authorities="$&#123;applicationId&#125;.android7.fileprovider" android:name="android.support.v4.content.FileProvider" android:exported="false" android:grantUriPermissions="true"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/file_paths"/&gt;&lt;/provider&gt; 声明provider的原因我是这样理解的：FileProvider是ContentProvider的一个子类 在文件共享时需要声明来告诉系统进行了文件共享操作。 meta-data,里面指向了一个xml文件。 编写resource xml file1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;paths xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;external-path name="my_images" path="/"/&gt; &lt;!--使用内部缓存--&gt;&lt;/paths&gt; 此文件的创建过程：res–&gt;xml–&gt;file_paths.xml。 在paths节点内部支持以下几个子节点，分别为： 相当于new File(“/“)，指向了整个存储的根目录。 相当于context.getFileDir() 返回文件系统上文件所在目录的绝对路径 相当于context.getCacheDir() 返回特定用于程序的缓存目录的绝对路径 相当于Environment.getExternalStorageDirectory() 返回主共享/外部存储目录。这个目录可能用户将其安装在其上 目前无法访问电脑 从设备中删除或一些问题发生了。使用此方法确定当前状态。 相当于context.getExternalFileDirs() 返回主数据库上特定于应用程序的目录的绝对路径共享外部存储设备，应用程序可以放置缓存它拥有的文件。这些程序是应用程序的内部文件，而不是通常作为媒体对用户可见。 相当于getExternalCacheDirs() 返回主数据库上特定于应用程序的目录的绝对路径共享外部存储设备，应用程序可以放置缓存它拥有的文件。这些程序是应用程序的内部文件，而不是通常作为媒体对用户可见。 这六个结点相对应的方法的作用 是我根据源码中对方法作用的注释 具体的区别我目前还不是很懂 我大概的理解是在拍照后照片需要存储在缓存文件中 我们需要给照片一个具体完整的路径 根据上面的六种基本路径存储方式会对应的得到一个文件路径头 后面的需要我们对应的补充。我看了很多博客大家都基本上选用结点 这个基础路径后面直接是图片的名称，即子目录。 使用FileProvider API主要代码就是：1FileProvider.getUriForFile(this,this.getPackageName()+".android7.fileprovider",outputImage); getUriForFile()方法中有三个参数 第二个参数很重要，可以随便命名但是必须和前面的provider中的authorities属性相对应,第三个参数是自定义的图片文件路径。 #Android4.4 7.0的区别 版本兼容的方法就是用版本校对1234567if(Build.VERSION.SDK_INT&gt;=24)&#123; imageUri = FileProvider.getUriForFile(this, this.getPackageName()+".android7.fileprovider",outputImage); Log.e("tag",imageUri.toString());&#125;else &#123; imageUri = Uri.fromFile(outputImage);&#125; 不用版本校对就需要为grantUriPermission进行授权。 主要思想就是通过获得应用中的包名加入到一个集合中，再通过for循环依次为当前符合条件的授权。 代码请参考鸿洋大神的博客Android 7.0 行为变更 通过FileProvider在应用间共享文件吧 使用FileProvider兼容安装apk自动安装apk在考虑到版本不同的情况下 和拍照获取图片又是不一样的。主要问题在于ACTION_IMAGE_CAPTURE 在startActivity后 会逐层调用一个方法intent.migrateExtraStreamToClipData();此方法中有setClipData()方法 将EXTRA_OUTPUT转化 还添加了FLAG_GRANT_WRITE_URI_PERMISSION|FLAG_GRANT_READ_URI_PERMISSION两种权限(对uri的读和写) 这些方法在自动安装中并不会调用所以需要我们自己申请。 下面是一个通用的类：12345678910111213141516171819202122232425262728293031public class FileProviderUtil &#123; public static Uri getUriForFile(Context context, File file)&#123; Uri fileUri = null; if(Build.VERSION.SDK_INT &gt; 24)&#123; fileUri = getUriForFile24(context,file); &#125; else &#123; fileUri = Uri.fromFile(file); &#125; return fileUri; &#125; public static Uri getUriForFile24(Context context,File file)&#123; Uri fileUrl = android.support.v4.content.FileProvider. getUriForFile(context,context.getPackageName()+".android7.fileprovider",file); return fileUrl; &#125; //为自动安装apk设置权限 public static void setIntentDataAndType(Context context, Intent intent, String type,File file,boolean writeAble)&#123; if(Build.VERSION.SDK_INT&gt;=24)&#123; intent.setDataAndType(getUriForFile(context,file),type); intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); if(writeAble)&#123; intent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION); &#125; &#125;else &#123; intent.setDataAndType(Uri.fromFile(file),type); &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[view篇1--------初识view]]></title>
    <url>%2F2019%2F04%2F12%2Fview%E7%AF%871-%E5%88%9D%E8%AF%86view%2F</url>
    <content type="text"><![CDATA[Android View篇—–初识viewview简介在Android操作系统中，几乎所有的UI元素都是基于View和ViewGroup创建出来的。View就是一块可以用来进行绘画，可以处理输入事件进行交互的矩形区域，而ViewGroup就是一种可以容纳View的矩形容器。 下图就是ViewGroup和View组成的UI布局结构。View和ViewGroup通过这种树形结构组合在一起，构成了我们在手机屏幕上看到的一个个的复杂的界面。 view ViewGroup和View是组合模式的典型应用。View是基本的控件元素，ViewManager接口定义了添加、删除View的接口addView、removeView，ViewGroup实现了ViewParent的接口，因此可以作为容器管理View，同时ViewGroup又继承自View，可以被其他的ViewGroup管理。这样ViewGroup和View就可以组成上面的树状结构了。 ViewManager结构图 实际的代码实现过程中很少会直接使用ViewGroup和View，而是使用继承自它们的之类，如FrameLayout、LinearLayout、ListView等是ViewGroup的子类，TextView、ImageView、SurfaceView等是View的子类。 View的位置参数想要学好view，写出自己的view就必须搞清楚view的位置参数。 view的位置主要是由它的四个顶点决定的，分别对应View的四个属性：top、left、right、bottom。 view的位置参数 view位置参数具体总结 MotionEvent在手指接触屏幕后所产生的一系列事件中，典型的事件类型有如下几种： ACTION_DOWN: 手指刚接触屏幕； ACTION_MOVE: 手指在屏幕上移动 ACTION_UP: 手指在屏幕上松开的一瞬间 上述是三种典型的点击事件，还有ACTION_POINTER_DOWN等。通过点击事件我们可以获得点击事件发生的x和y坐标。 系统提供了两种方法： event.getX() / event.getY() 返回的是相对于当前view左上角的坐标x和y event.getRawX() / event.getRawY() 返回的是相对于手机屏幕左上角的坐标x和y TouchSlopTouchSlop是系统所能识别出的被认为是滑动的最小距离。也就是，当手指在屏幕上滑动时，如果两次滑动的这个距离小于这个常量，系统就不认为你是在进行滑动操作。这个常量和设备有关，通常用如下方式获得这个常量：1ViewConfiguration.get(getContext()).getScaledTouchSlop() VelocityTracker速度追踪，用于追踪手指在滑动的过程中的速度，包括水平和竖直方向的速度。首先，在view的onTouchEvent方法中追踪当前单击事件的速度，123VelocityTracker velocityTracker = VelocityTracker.obtain();velocityTracker.addMovement(event); 接着，当我们想知道当前的滑动速度时，这个时候可以采用如下方式来获得当前的速度：123velocityTracker.computeCurrentVelocity(1000);int xVelocity = (int) velocityTracker.getXVelocity();int yVelocity = (int) velocityTracker.getYVelocity(); 有两点需要注意： 获取速度之前必须要先计算速度，即getXVelocity和getYVelocity这两个方法前必须要调用computeCurrentVelocity方法。 这里的速度是指一段时间内手指所滑过的像素数，比如将时间设为1000ms,在1s内，手指在水平方向从左向右滑过100像素，那么水平速度就是100。注意速度可以为负值，即当手指从右向左滑动的时候。另外，computeCurrentVelocity这个方法的参数表示的是一个时间单元或者说是时间间隔，单位是毫秒(ms)。 最后，当不需要使用它的时候，需要调用clear方法来重置并回收内存：12velocityTracker.clear();velocityTracker.recycle(); GestureDetector 在写项目的时候，想要实现图片双指缩放的功能，在网上看见了有用GestureDetector来实现的方法，但是一般在onTouchEvent中实现就可以，主要还是看个人习惯，像双击的话就用GestureDetector中的方法比较方便。 GestureDetector用于手势检测，用于辅助检测用户的单击、滑动、长按、双击等行为。 GestureDetector这个类对外部提供了两个接口和一个外部类，其中包括： 接口：OnGestureListener OnDoubleTapListener 内部类：SimpleOnGestureListener OnGestureListener基本使用首先在MainActivity中定义我们的手势监听器，并让的当前的Acticity来实现监听接口：1234567891011//定义手势监听器GestureDetector mGestureDetector;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mGestureDetector = new GestureDetector(this,this); //解决长按屏幕后无法拖动的现象 mGestureDetector.setIsLongpressEnabled(false);&#125; 实现接口中的回调方法：12345678910111213141516171819202122232425262728293031323334353637383940//手指轻轻触摸屏幕的一瞬间，由一个ACTION_DOWN触发@Overridepublic boolean onDown(MotionEvent e) &#123; System.out.println("onDown"); return false;&#125;//手指轻轻触摸屏幕,尚未松开或拖动，由一个ACTION_DOWN触发//注意和onDown()的区别，他强调的是没有松开或者拖动的状态@Overridepublic void onShowPress(MotionEvent e) &#123; System.out.println("onShowPress");&#125;//手指(轻轻触摸屏幕后)松开，伴随着一个ACTION_UP而触发，这是单机行为@Overridepublic boolean onSingleTapUp(MotionEvent e) &#123; System.out.println("onSingleTapUp"); return false;&#125;//手指按下屏幕并拖动，由一个ACTION_DOWN,多个ACTION_MOVE触发，这是拖动行为@Overridepublic boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123; System.out.println("onScroll"); return false;&#125;//用户长久的按着屏幕不放，即长按@Overridepublic void onLongPress(MotionEvent e) &#123; System.out.println("onLongPress");&#125;//用户按下触摸屏，快速滑动后松开，由一个ACTION_DOWN,多个ACTION_MOVE和一个ACTION_UP触发，这是快速滑动行为@Overridepublic boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#123; System.out.println("onFling"); return false;&#125; 最后将Activity中的OnTouchEvent事件交给手势监听器处理：1234@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; return gestureDetector.onTouchEvent(event);&#125; OnDoubleTapListener基本使用:同样的让MainActivity也实现OnDoubleTapListener接口。1public class MainActivity extends Activity implements OnGestureListener,OnDoubleTapListener 实现对应的抽象方法：123456789101112131415161718192021//双击，由两次连续的单击组成，它不可能和onSingleTapConfirmed共存(当系统接受到双击事件的时候会在两次点击之间触发一次下面的方法)@Overridepublic boolean onDoubleTap(MotionEvent e) &#123; System.out.println("onDoubleTap"); return false;&#125;//严格的单击行为//和onSingleTapUp的区别：如果触发了onSingleTapConfirmed，那么后面不可能在紧跟着另一个单击行为，即这只可能是单击，而不可能是双击中的一次单击@Overridepublic boolean onSingleTapConfirmed(MotionEvent e) &#123; System.out.println("onSingleTapConfirmed"); return false;&#125;//表示发生了双击行为，在双击的期间，ACTION_DOWN ACTION_MOVE ACTION_UP都会触发此回调(当系统接收到双击事件的时候,在每一次的结束触发下面的方法一次) @Overridepublic boolean onDoubleTapEvent(MotionEvent e) &#123; System.out.println("onDoubleTapEvent"); return false;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[]]></title>
    <url>%2F2019%2F04%2F08%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[onDraw()方法中的Canvas的大小是多少 控件的大小是wrap_content时 getMeasuredWidth()是如何测量的 IPC过程]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
