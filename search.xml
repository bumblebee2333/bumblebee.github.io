<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[view事件分发源码分析]]></title>
    <url>%2F2019%2F05%2F19%2Fview%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[view事件分发源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public boolean dispatchTouchEvent(MotionEvent event) &#123; // If the event should be handled by accessibility focus first. //---&gt;分析一 //判断事件是否具有焦点可访问性(是否可以获取焦点)(isFocusable isFocusableInTouchMode) if (event.isTargetAccessibilityFocus()) &#123; // We don't have focus or no virtual descendant has it, do not handle the event. //当前view和它的子view都不可以获取焦点 返回false if (!isAccessibilityFocusedViewOrHost()) &#123; return false; &#125; // We have focus and got the event, then use normal event dispatch. //取消FLAG_TARGET_ACCESSIBILITY_FOCUS标志 进行正常的事件分发 event.setTargetAccessibilityFocus(false); &#125; boolean result = false; //如果事件检查对象不为空，就检查这个事件，包括检查事件序列完整性等等。 if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(event, 0); &#125; final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Defensive cleanup for new gesture //停止嵌套滑动 //当嵌套滑动当前不在进行时调用本方法是无害的 //NestedScrolling stopNestedScroll(); &#125; //---&gt;分析二 //安全检查当前事件 if (onFilterTouchEventForSecurity(event)) &#123; //当前view可用且当前事件是为了操作滚动条的 返回true if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123; result = true; &#125; //noinspection SimplifiableIfStatement //---&gt;分析三 ListenerInfo li = mListenerInfo; //尝试onTouch处理 //1.listenerInfo不为空 //2.ListenerInfo的OnTouchListener不为空 //3.该view是ENABLED的 //OnTouchListener的OnTouch()返回true if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; //---&gt;分析四 if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; //如果经过上面的操作，事件还没有处理 if (!result &amp;&amp; mInputEventConsistencyVerifier != null) &#123; //调用onUnhandledEvent(),这个事件的后序检查追踪不需要做了 mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); &#125; // Clean up after nested scrolls if this is the end of a gesture; // also cancel it if we tried an ACTION_DOWN but we didn't want the rest // of the gesture. if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123; stopNestedScroll(); &#125; return result;&#125; 分析一焦点分为两种： 硬键盘焦点focusable 通过硬键盘（或物理键盘：蓝牙键盘等）上下左右操作焦点，点击，输入。 触摸焦点focusableInTouchMode针对触屏情况下，点击屏幕的控件，先触发 OnFocusChangeListener，获取控件焦点，然后执行点击事件。EditText是默认有触摸获取焦点功能的，并将第一抢先获取焦点，因此页面有EditText的时默认有光标，键盘弹出。 设置一个视图是否可以获取焦点可以通过以下方法：1234//设置视图是否可以获得焦点public void setFocusable(boolean focusable) //获取视图是否可以获取焦点public final boolean isFocusable() 触摸设备来说，一个视图在触摸下是否可以成为焦点视图：1234//设置视图是否在触摸模式下可以获得焦点 public void setFocusableInTouchMode(boolean focusableInTouchMode) //获取视图是否在触摸模式下获得焦点public final boolean isFocusableInTouchMode() 一个视图要想获得焦点必须要setFocusable和setFocusableInTouchMode同时为true时才可以获取焦点。 下面两个方法用来判断某个视图是否是焦点视图以及是否获取了焦点：1234//是否当前视图就是焦点视图public boolean isFocused() //当前视图是否是焦点视图，或者子视图里面有焦点视图。public boolean hasFocus() event.isTargetAccessibilityFocus()12345/** @hide */public final boolean isTargetAccessibilityFocus() &#123; final int flags = getFlags(); return (flags &amp; FLAG_TARGET_ACCESSIBILITY_FOCUS) != 0;&#125; Android在系统级别引入了辅助功能选项来帮助有障碍的用户使用系统，所以一个事件带有FLAG_TARGET_ACCESSIBILITY_FOCUS标志，说明这是一个特殊的辅助功能事件，需要进行特殊处理。 ev.setTargetAccessibilityFocus(false)1234567/** @hide */public final void setTargetAccessibilityFocus(boolean targetsFocus) &#123; final int flags = getFlags(); nativeSetFlags(mNativePtr, targetsFocus ? flags | FLAG_TARGET_ACCESSIBILITY_FOCUS : flags &amp; ~FLAG_TARGET_ACCESSIBILITY_FOCUS);&#125; 取消标志，进行普通分发。 分析二 过滤触摸事件以应用安全策略123456789public boolean onFilterTouchEventForSecurity(MotionEvent event) &#123; //视图窗口被遮挡且接收到运动事件的窗口是部分的或完全被遮挡(安全敏感程序 恶意应用程序) if ((mViewFlags &amp; FILTER_TOUCHES_WHEN_OBSCURED) != 0 &amp;&amp; (event.getFlags() &amp; MotionEvent.FLAG_WINDOW_IS_OBSCURED) != 0) &#123; // Window is obscured, drop this touch. return false; &#125; return true;&#125; 分析三 ListenerInfo Listener used to dispatch focus change events. This field should be made private, so it is hidden from the SDK. (监听器用于发送焦点变化事件。 此字段应设为私有字段，对SDK隐藏。) 分析四 onTouch和onTouchEvent onTouch方法： onTouch()是OnTouchListener接口的方法，它是获取某一个控件的触摸事件，因此使用时，必须使用setOnTouchListener绑定到控件，然后才能鉴定该控件的触摸事件。当一个View绑定了OnTouchLister后，当有touch事件触发时，就会调用onTouch方法。 123456789101112textview.setOnTouchListener(new OnTouchListener)&#123; public boolean onTouch(View v,MotionEvent event)&#123; switch(event.getAction())&#123; case MotionEvent.ACTION_DOWN: break; ... default: break; &#125; return true; &#125;&#125; onTouchEvent()方法 onTouchEvent是手机屏幕事件的处理方法，是获取的对屏幕的各种操作，比如向左向右滑动，点击返回按钮等等。属于一个宏观的屏幕触摸监控。onTouchEvent方法是override 的Activity的方法。重写了Activity的onTouchEvent方法后，当屏幕有touch事件时，此方法就会被调用。 12345678910111213141516171819202122232425262728293031323334public boolean onTouchEvent(MotionEvent event) &#123; final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); //判断当前view是否可点击：CLICKABLE、LONG_CLICKABLE、CONTEXT_CLICKABLE final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE; //如果当前view是不可用的 if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; //是UP事件且view状态为按下(FLAG_PRESSED) if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; //重置当前view的FLAG_PRESSED状态 setPressed(false); &#125; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. //一个不可用的view还是能消耗事件，只是不会做出反馈。直接返回是否能够点击。 return clickable; &#125; //扩大点击事件的范围 if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; //可点击或者TOOLTIP(此视图可以在悬停或者长按时显示工具提示) if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123; switch (action) &#123; case MotionEvent.ACTION_UP: ··· break; } return true; } return false; }1### setPressed() public void setPressed(boolean pressed) { final boolean needsRefresh = pressed != ((mPrivateFlags &amp; PFLAG_PRESSED) == PFLAG_PRESSED); //重置按下状态 if (pressed) { mPrivateFlags |= PFLAG_PRESSED; } else { mPrivateFlags &amp;= ~PFLAG_PRESSED; } if (needsRefresh) { //强制视图更新其可绘制状态 refreshDrawableState(); } // dispatchSetPressed(pressed); }12### TouchDelegate(扩展控件的关键类)&gt; 扩大view事件的点击范围 public TouchDelegate(Rect bounds, View delegateView)12345```TouchDelegate touchDelegate = new TouchDelegate(delegateArea, myButton);if (View.class.isInstance(myButton.getParent())) &#123; ((View) myButton.getParent()).setTouchDelegate(touchDelegate);&#125; ACTION_DOWN1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//输入设备的输入源是触摸屏幕指示设备if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) &#123; mPrivateFlags3 |= PFLAG3_FINGER_DOWN;&#125;//是否长按mHasPerformedLongPress = false;//view不可点击if (!clickable) &#123; //检查长按后结束 checkForLongClick(0, x, y); break;&#125;//在DOWN事件期间 执行与按钮相关的操作(鼠标右键)if (performButtonActionOnTouchDown(event)) &#123; break;&#125;// Walk up the hierarchy to determine if we're inside a scrolling container.//判断该view是否有一层父类是可滑动的boolean isInScrollingContainer = isInScrollingContainer();// For views inside a scrolling container, delay the pressed feedback for// a short period in case this is a scroll.//对滚动容器内的视图，延时按下的反馈。//单击时间一般很短 以防是一个滚动if (isInScrollingContainer) &#123; //在滚动容器内 设置PFLAG_PREPRESSED标志位 mPrivateFlags |= PFLAG_PREPRESSED; //若单击为null if (mPendingCheckForTap == null) &#123; mPendingCheckForTap = new CheckForTap(); //CheckForTap的run()方法 &lt;!--@Override--&gt; &lt;!--public void run() &#123;--&gt; //设置非预按下状态 &lt;!-- mPrivateFlags &amp;= ~PFLAG_PREPRESSED;--&gt; //设置FLAG_PRESSED状态和drawableHotspotChanged(x,y) &lt;!-- setPressed(true, x, y);--&gt; &lt;!-- //检查长按 checkForLongClick(ViewConfiguration.getTapTimeout(), x, y);--&gt; &lt;!--&#125;--&gt; &#125; mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); //点击任务延时加入执行队里 postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());&#125; else &#123; // Not inside a scrolling container, so show the feedback right away //不在滑动容器内 设置按下 检查长按 setPressed(true, x, y); checkForLongClick(0, x, y);&#125; 123456789101112131415161718192021222324252627private void checkForLongClick(int delayOffset, float x, float y) &#123; //长按或TOOLTIP if ((mViewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE || (mViewFlags &amp; TOOLTIP) == TOOLTIP) &#123; //设置长按为false mHasPerformedLongPress = false; //初始化长按 执行runnable if (mPendingCheckForLongPress == null) &#123; mPendingCheckForLongPress = new CheckForLongPress(); &#125; mPendingCheckForLongPress.setAnchor(x, y); mPendingCheckForLongPress.rememberWindowAttachCount(); mPendingCheckForLongPress.rememberPressedState(); //将长按Runnable加入执行队 postDelayed(mPendingCheckForLongPress, ViewConfiguration.getLongPressTimeout() - delayOffset); &#125;&#125;//CheckForLongPress中的run@Overridepublic void run() &#123; if ((mOriginalPressedState == isPressed()) &amp;&amp; (mParent != null) &amp;&amp; mOriginalWindowAttachCount == mWindowAttachCount) &#123; if (performLongClick(mX, mY)) &#123; mHasPerformedLongPress = true; &#125; &#125;&#125; ACTION_MOVE 123456789101112131415161718192021222324//如果可以点击if (clickable) &#123; //修改热点状态 drawableHotspotChanged(x, y);&#125;// Be lenient about moving outside of buttons//x,y在本地坐标中且x,y+slop扩展的区域在视图区域范围内if (!pointInView(x, y, mTouchSlop)) &#123; &lt;!--public boolean pointInView(float localX, float localY, float slop) &#123;--&gt; &lt;!-- return localX &gt;= -slop &amp;&amp; localY &gt;= -slop &amp;&amp; localX &lt; ((mRight - mLeft) + slop) &amp;&amp;--&gt; &lt;!-- localY &lt; ((mBottom - mTop) + slop);--&gt; &lt;!--&#125;--&gt; // Outside button // Remove any future long press/tap checks //超出范围 移除点击、长按线程 removeTapCallback(); removeLongPressCallback(); //恢复未按下状态 if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;&#125; ACTION_CANCLE 123456789101112//恢复未按下状态if (clickable) &#123; setPressed(false);&#125;//移除点击或长按线程removeTapCallback();removeLongPressCallback();//初始化状态mInContextButtonPress = false;mHasPerformedLongPress = false;mIgnoreNextUpEvent = false;mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; ACTION_UP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;//如果是tooltip(工具提示 用户长按视图或者鼠标悬停在试图上时 消息显示在视图附近)if ((viewFlags &amp; TOOLTIP) == TOOLTIP) &#123; //---&gt;分析1 handleTooltipUp();&#125;//若是tooltip 恢复状态后结束if (!clickable) &#123; removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; break;&#125;//在嵌套滑动视图的DOWN事件中标记过boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123; // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; // 判断该View是否为可获得焦点且设置了focusableInTouchMode为true并且还没有获得焦点时 // 设置focusable意思是控件是否能够获得普通焦点，这个可以理解为通过物理键盘， // 因为Android不仅仅针对手机，有可能在某些设备上存在上下键， // 如果focusable设置为true，那么键盘上下左右选中，焦点会随之移动。 // focusableInTouchMode意思是控件是否能触摸获得焦点， // 如果设置为true，点击后首先会让View获得焦点，获取后才出发点击事件。 //---&gt;分析2 if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; //尝试获得焦点 设置focusTaken focusTaken = requestFocus(); &#125; // prepressed状态表示滚动容器中的点击检测还没有被消息队列执行，这个时候如果抬起手指说明是一个点击事件，调用setPressed显示反馈 if (prepressed) &#123; // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. //处理还没来得及显示的按下状态 //例如 down事件时延时显示按下状态 到了up事件还没有显示 setPressed(true, x, y); &lt;!--private void setPressed(boolean pressed, float x, float y) &#123;--&gt; &lt;!-- if (pressed) &#123;--&gt; //更新视图热点 &lt;!-- drawableHotspotChanged(x, y);--&gt; &lt;!-- &#125;--&gt; &lt;!-- setPressed(pressed);--&gt; &lt;!--&#125;--&gt; &#125; //没有执行长按且不会忽略虚假次UP事件 if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state //没有通过获取焦点的操作 //有可能是因为物理或触摸模式为false 也可能在之前已经获得了焦点 if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. //通过Runnable和post 将点击事件加入消息队列来让其他视图在单击操作开始之前进行视图更新 ---&gt;分析3 if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); //performClick()调用onClick()方法 &#125; ---&gt;分析4 if (!post(mPerformClick)) &#123; //如果加入失败，就直接调用performClick() performClickInternal(); &#125; &#125; &#125; //如果还没有设置回未按下状态 if (mUnsetPressedState == null) &#123; mUnsetPressedState = new UnsetPressedState(); &lt;!--private final class UnsetPressedState implements Runnable &#123;--&gt; &lt;!-- @Override--&gt; &lt;!-- public void run() &#123;--&gt; &lt;!-- setPressed(false);--&gt; &lt;!-- &#125;--&gt; &lt;!--&#125;--&gt; &#125; //如果外层有滑动父view if (prepressed) &#123; //延时发送设置未按下的操作 postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); &#125; else if (!post(mUnsetPressedState)) &#123; // If the post failed, unpress right now //如果父类没有滑动 直接发送设置未按下状态的操作到执行队列 //如果没有加入成功 就直接调用run()方法 mUnsetPressedState.run(); &#125; //移除tap的runnbale removeTapCallback();&#125;//不忽略接收下次的ACTION_UP事件mIgnoreNextUpEvent = false; 1.handleTooltipUp()12345678910private void handleTooltipUp() &#123; if (mTooltipInfo == null || mTooltipInfo.mTooltipPopup == null) &#123; return; &#125; //移除隐藏的runnable removeCallbacks(mTooltipInfo.mHideTooltipRunnable); //将隐藏的runnable加入消息队列 经过指定的时间 runnable将在主界面运行 postDelayed(mTooltipInfo.mHideTooltipRunnable, ViewConfiguration.getLongPressTooltipHideTimeout());&#125; 2.判断view是否可以获得焦点12345678910111213//返回当前view是否能够获得焦点public final boolean isFocusable() &#123; return FOCUSABLE == (mViewFlags &amp; FOCUSABLE);&#125;//当视图可聚焦时 在触摸模式下可能不想聚焦//返回当前view在触摸模式下是否能够获得焦点public final boolean isFocusableInTouchMode() &#123; return FOCUSABLE_IN_TOUCH_MODE == (mViewFlags &amp; FOCUSABLE_IN_TOUCH_MODE);&#125;//视图有焦点 返会truepublic boolean isFocused() &#123; return (mPrivateFlags &amp; PFLAG_FOCUSED) != 0;&#125; 3.PerformClick123456789101112131415161718192021222324252627282930313233private final class PerformClick implements Runnable &#123; @Override public void run() &#123; performClickInternal(); &#125;&#125;private boolean performClickInternal() &#123; notifyAutofillManagerOnClick(); return performClick();&#125;public boolean performClick() &#123; // We still need to call this method to handle the cases where performClick() was called // externally, instead of through performClickInternal() notifyAutofillManagerOnClick(); final boolean result; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) &#123; //触发声效 playSoundEffect(SoundEffectConstants.CLICK); //调用onClick() li.mOnClickListener.onClick(this); result = true; &#125; else &#123; result = false; &#125; //发送辅助功能事件 sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); notifyEnterOrExitForAutoFillIfNeeded(true); return result;&#125; post(mPerformClick)1234567891011public boolean post(Runnable action) &#123; final AttachInfo attachInfo = mAttachInfo; if (attachInfo != null) &#123; return attachInfo.mHandler.post(action); &#125; // Postpone the runnable until we know on which thread it needs to run. // Assume that the runnable will be successfully placed after attach. getRunQueue().post(action); return true;&#125; 总结view事件分发流程图 onTouchEvent()方法流程图 参考文章超级详细]]></content>
  </entry>
  <entry>
    <title><![CDATA[简单总结FileProvider]]></title>
    <url>%2F2019%2F05%2F19%2F%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93FileProvider%2F</url>
    <content type="text"><![CDATA[概述FileProvider继承自ContentProvider 从英语翻译过来就是文件提供 也就是文件共享 当我们需要使用本地的文件时(这样说好像不太对) 例如调用相机拍照 需要将照片显示在屏幕上 照片是需要缓存在sdcard的缓存文件目录中的 这时就会用到FileProvider。 还有一个用处就是在自动安装apk上 我们经常会遇到app更新 此时系统会自动弹出一个框让我们更新并安装。 FileProvider使用时需要注意的一个地方就是Android7.0版本以后和Android4.4之前 对uri(通用资源标识符 Android上可用的每种资源-图像、视频片段都可以用uri来表示)的操作是不一样的。 相机获取本地图片最近写了一个demo 主要是想实现从相册 本地获取的照片通过画布展现在屏幕上 并实现图片的保存。 下面就贴下我写的开启照相机拍照的代码：1234567891011121314151617181920public void takePhoto()&#123; //判断设备中是否存在sdcard String SDState = Environment.getExternalStorageState(); Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); if(SDState.equals(Environment.MEDIA_MOUNTED))&#123; File outputImage = new File(getExternalCacheDir(),"output_image.jpg"); if(!outputImage.exists())&#123; outputImage.mkdir(); &#125; if(Build.VERSION.SDK_INT&gt;=24)&#123; imageUri = FileProvider.getUriForFile(this, this.getPackageName()+".android7.fileprovider",outputImage); Log.e("tag",imageUri.toString()); &#125;else &#123; imageUri = Uri.fromFile(outputImage); &#125; &#125; intent.putExtra(MediaStore.EXTRA_OUTPUT,imageUri); startActivityForResult(intent,SELECT_PIC_BY_TAKE_PHOTO);&#125; 解决FileUriExposedException在没有用FileProvider 只用Uri.fromFile()是对file://的访问 对于Android7.0来说是禁止的 要在应用间共享文件 应发送一项content://URL 并授予URL临时访问权限 这时就需要用到FileProvider。 使用FileProvider兼容拍照需要以下几个步骤： 声明provider123456789&lt;provider android:authorities="$&#123;applicationId&#125;.android7.fileprovider" android:name="android.support.v4.content.FileProvider" android:exported="false" android:grantUriPermissions="true"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/file_paths"/&gt;&lt;/provider&gt; 声明provider的原因我是这样理解的：FileProvider是ContentProvider的一个子类 在文件共享时需要声明来告诉系统进行了文件共享操作。 meta-data,里面指向了一个xml文件。 编写resource xml file1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;paths xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;external-path name="my_images" path="/"/&gt; &lt;!--使用内部缓存--&gt;&lt;/paths&gt; 此文件的创建过程：res–&gt;xml–&gt;file_paths.xml。 在paths节点内部支持以下几个子节点，分别为： 相当于new File(“/“)，指向了整个存储的根目录。 相当于context.getFileDir() 返回文件系统上文件所在目录的绝对路径 相当于context.getCacheDir() 返回特定用于程序的缓存目录的绝对路径 相当于Environment.getExternalStorageDirectory() 返回主共享/外部存储目录。这个目录可能用户将其安装在其上 目前无法访问电脑 从设备中删除或一些问题发生了。使用此方法确定当前状态。 相当于context.getExternalFileDirs() 返回主数据库上特定于应用程序的目录的绝对路径共享外部存储设备，应用程序可以放置缓存它拥有的文件。这些程序是应用程序的内部文件，而不是通常作为媒体对用户可见。 相当于getExternalCacheDirs() 返回主数据库上特定于应用程序的目录的绝对路径共享外部存储设备，应用程序可以放置缓存它拥有的文件。这些程序是应用程序的内部文件，而不是通常作为媒体对用户可见。 这六个结点相对应的方法的作用 是我根据源码中对方法作用的注释 具体的区别我目前还不是很懂 我大概的理解是在拍照后照片需要存储在缓存文件中 我们需要给照片一个具体完整的路径 根据上面的六种基本路径存储方式会对应的得到一个文件路径头 后面的需要我们对应的补充。我看了很多博客大家都基本上选用结点 这个基础路径后面直接是图片的名称，即子目录。 使用FileProvider API主要代码就是：1FileProvider.getUriForFile(this,this.getPackageName()+".android7.fileprovider",outputImage); getUriForFile()方法中有三个参数 第二个参数很重要，可以随便命名但是必须和前面的provider中的authorities属性相对应,第三个参数是自定义的图片文件路径。 #Android4.4 7.0的区别 版本兼容的方法就是用版本校对1234567if(Build.VERSION.SDK_INT&gt;=24)&#123; imageUri = FileProvider.getUriForFile(this, this.getPackageName()+".android7.fileprovider",outputImage); Log.e("tag",imageUri.toString());&#125;else &#123; imageUri = Uri.fromFile(outputImage);&#125; 不用版本校对就需要为grantUriPermission进行授权。 主要思想就是通过获得应用中的包名加入到一个集合中，再通过for循环依次为当前符合条件的授权。 代码请参考鸿洋大神的博客Android 7.0 行为变更 通过FileProvider在应用间共享文件吧 使用FileProvider兼容安装apk自动安装apk在考虑到版本不同的情况下 和拍照获取图片又是不一样的。主要问题在于ACTION_IMAGE_CAPTURE 在startActivity后 会逐层调用一个方法intent.migrateExtraStreamToClipData();此方法中有setClipData()方法 将EXTRA_OUTPUT转化 还添加了FLAG_GRANT_WRITE_URI_PERMISSION|FLAG_GRANT_READ_URI_PERMISSION两种权限(对uri的读和写) 这些方法在自动安装中并不会调用所以需要我们自己申请。 下面是一个通用的类：12345678910111213141516171819202122232425262728293031public class FileProviderUtil &#123; public static Uri getUriForFile(Context context, File file)&#123; Uri fileUri = null; if(Build.VERSION.SDK_INT &gt; 24)&#123; fileUri = getUriForFile24(context,file); &#125; else &#123; fileUri = Uri.fromFile(file); &#125; return fileUri; &#125; public static Uri getUriForFile24(Context context,File file)&#123; Uri fileUrl = android.support.v4.content.FileProvider. getUriForFile(context,context.getPackageName()+".android7.fileprovider",file); return fileUrl; &#125; //为自动安装apk设置权限 public static void setIntentDataAndType(Context context, Intent intent, String type,File file,boolean writeAble)&#123; if(Build.VERSION.SDK_INT&gt;=24)&#123; intent.setDataAndType(getUriForFile(context,file),type); intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); if(writeAble)&#123; intent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION); &#125; &#125;else &#123; intent.setDataAndType(Uri.fromFile(file),type); &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[view篇1--------初识view]]></title>
    <url>%2F2019%2F04%2F12%2Fview%E7%AF%871-%E5%88%9D%E8%AF%86view%2F</url>
    <content type="text"><![CDATA[Android View篇—–初识viewview简介在Android操作系统中，几乎所有的UI元素都是基于View和ViewGroup创建出来的。View就是一块可以用来进行绘画，可以处理输入事件进行交互的矩形区域，而ViewGroup就是一种可以容纳View的矩形容器。 下图就是ViewGroup和View组成的UI布局结构。View和ViewGroup通过这种树形结构组合在一起，构成了我们在手机屏幕上看到的一个个的复杂的界面。 view ViewGroup和View是组合模式的典型应用。View是基本的控件元素，ViewManager接口定义了添加、删除View的接口addView、removeView，ViewGroup实现了ViewParent的接口，因此可以作为容器管理View，同时ViewGroup又继承自View，可以被其他的ViewGroup管理。这样ViewGroup和View就可以组成上面的树状结构了。 ViewManager结构图 实际的代码实现过程中很少会直接使用ViewGroup和View，而是使用继承自它们的之类，如FrameLayout、LinearLayout、ListView等是ViewGroup的子类，TextView、ImageView、SurfaceView等是View的子类。 View的位置参数想要学好view，写出自己的view就必须搞清楚view的位置参数。 view的位置主要是由它的四个顶点决定的，分别对应View的四个属性：top、left、right、bottom。 view的位置参数 view位置参数具体总结 MotionEvent在手指接触屏幕后所产生的一系列事件中，典型的事件类型有如下几种： ACTION_DOWN: 手指刚接触屏幕； ACTION_MOVE: 手指在屏幕上移动 ACTION_UP: 手指在屏幕上松开的一瞬间 上述是三种典型的点击事件，还有ACTION_POINTER_DOWN等。通过点击事件我们可以获得点击事件发生的x和y坐标。 系统提供了两种方法： event.getX() / event.getY() 返回的是相对于当前view左上角的坐标x和y event.getRawX() / event.getRawY() 返回的是相对于手机屏幕左上角的坐标x和y TouchSlopTouchSlop是系统所能识别出的被认为是滑动的最小距离。也就是，当手指在屏幕上滑动时，如果两次滑动的这个距离小于这个常量，系统就不认为你是在进行滑动操作。这个常量和设备有关，通常用如下方式获得这个常量：1ViewConfiguration.get(getContext()).getScaledTouchSlop() VelocityTracker速度追踪，用于追踪手指在滑动的过程中的速度，包括水平和竖直方向的速度。首先，在view的onTouchEvent方法中追踪当前单击事件的速度，123VelocityTracker velocityTracker = VelocityTracker.obtain();velocityTracker.addMovement(event); 接着，当我们想知道当前的滑动速度时，这个时候可以采用如下方式来获得当前的速度：123velocityTracker.computeCurrentVelocity(1000);int xVelocity = (int) velocityTracker.getXVelocity();int yVelocity = (int) velocityTracker.getYVelocity(); 有两点需要注意： 获取速度之前必须要先计算速度，即getXVelocity和getYVelocity这两个方法前必须要调用computeCurrentVelocity方法。 这里的速度是指一段时间内手指所滑过的像素数，比如将时间设为1000ms,在1s内，手指在水平方向从左向右滑过100像素，那么水平速度就是100。注意速度可以为负值，即当手指从右向左滑动的时候。另外，computeCurrentVelocity这个方法的参数表示的是一个时间单元或者说是时间间隔，单位是毫秒(ms)。 最后，当不需要使用它的时候，需要调用clear方法来重置并回收内存：12velocityTracker.clear();velocityTracker.recycle(); GestureDetector 在写项目的时候，想要实现图片双指缩放的功能，在网上看见了有用GestureDetector来实现的方法，但是一般在onTouchEvent中实现就可以，主要还是看个人习惯，像双击的话就用GestureDetector中的方法比较方便。 GestureDetector用于手势检测，用于辅助检测用户的单击、滑动、长按、双击等行为。 GestureDetector这个类对外部提供了两个接口和一个外部类，其中包括： 接口：OnGestureListener OnDoubleTapListener 内部类：SimpleOnGestureListener OnGestureListener基本使用首先在MainActivity中定义我们的手势监听器，并让的当前的Acticity来实现监听接口：1234567891011//定义手势监听器GestureDetector mGestureDetector;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mGestureDetector = new GestureDetector(this,this); //解决长按屏幕后无法拖动的现象 mGestureDetector.setIsLongpressEnabled(false);&#125; 实现接口中的回调方法：12345678910111213141516171819202122232425262728293031323334353637383940//手指轻轻触摸屏幕的一瞬间，由一个ACTION_DOWN触发@Overridepublic boolean onDown(MotionEvent e) &#123; System.out.println("onDown"); return false;&#125;//手指轻轻触摸屏幕,尚未松开或拖动，由一个ACTION_DOWN触发//注意和onDown()的区别，他强调的是没有松开或者拖动的状态@Overridepublic void onShowPress(MotionEvent e) &#123; System.out.println("onShowPress");&#125;//手指(轻轻触摸屏幕后)松开，伴随着一个ACTION_UP而触发，这是单机行为@Overridepublic boolean onSingleTapUp(MotionEvent e) &#123; System.out.println("onSingleTapUp"); return false;&#125;//手指按下屏幕并拖动，由一个ACTION_DOWN,多个ACTION_MOVE触发，这是拖动行为@Overridepublic boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123; System.out.println("onScroll"); return false;&#125;//用户长久的按着屏幕不放，即长按@Overridepublic void onLongPress(MotionEvent e) &#123; System.out.println("onLongPress");&#125;//用户按下触摸屏，快速滑动后松开，由一个ACTION_DOWN,多个ACTION_MOVE和一个ACTION_UP触发，这是快速滑动行为@Overridepublic boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#123; System.out.println("onFling"); return false;&#125; 最后将Activity中的OnTouchEvent事件交给手势监听器处理：1234@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; return gestureDetector.onTouchEvent(event);&#125; OnDoubleTapListener基本使用:同样的让MainActivity也实现OnDoubleTapListener接口。1public class MainActivity extends Activity implements OnGestureListener,OnDoubleTapListener 实现对应的抽象方法：123456789101112131415161718192021//双击，由两次连续的单击组成，它不可能和onSingleTapConfirmed共存(当系统接受到双击事件的时候会在两次点击之间触发一次下面的方法)@Overridepublic boolean onDoubleTap(MotionEvent e) &#123; System.out.println("onDoubleTap"); return false;&#125;//严格的单击行为//和onSingleTapUp的区别：如果触发了onSingleTapConfirmed，那么后面不可能在紧跟着另一个单击行为，即这只可能是单击，而不可能是双击中的一次单击@Overridepublic boolean onSingleTapConfirmed(MotionEvent e) &#123; System.out.println("onSingleTapConfirmed"); return false;&#125;//表示发生了双击行为，在双击的期间，ACTION_DOWN ACTION_MOVE ACTION_UP都会触发此回调(当系统接收到双击事件的时候,在每一次的结束触发下面的方法一次) @Overridepublic boolean onDoubleTapEvent(MotionEvent e) &#123; System.out.println("onDoubleTapEvent"); return false;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[]]></title>
    <url>%2F2019%2F04%2F08%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[onDraw()方法中的Canvas的大小是多少 控件的大小是wrap_content时 getMeasuredWidth()是如何测量的 IPC过程]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
